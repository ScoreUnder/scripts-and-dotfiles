#!/usr/bin/env perl
use Scalar::Util 'looks_like_number';

sub normalise_time {
    my @parts = split /:/, $_[0];
    my $res = 0;
    $res = $res * 60 + $_ for @parts;
    $res;
}

sub round_3dp {
    sprintf "%.3f", @_;
}

my $pci = qx[lspci];
my $hardware;
if ($pci =~ /AMD.*Radeon/) {
    $hardware = "amd";
} elsif ($pci =~ /NVIDIA.*GeForce/) {
    $hardware = "nvidia";
} else {
    $hardware = "none";
}

my (@afilters, @vfilters);

while ($ARGV[0] =~ /^-/) {
    for ($ARGV[0]) {
        if (/^--afadeout=(.*)$/) {
            my $fadetime = $1;
            push @afilters, sub {
                my ($in, $out, $from, $to) = @_;
                die "Can't fade out unless exact cut points are provided\n"
                    unless looks_like_number($from) && looks_like_number($to);
                my $duration = $to - $from;
                my $fade_start = round_3dp($duration - $fadetime);
                return "afade=t=out:st=$fade_start:d=$fadetime"
            };
        } elsif (/^--afadein=(.*)$/) {
            my $fadetime = $1;
            push @afilters, sub {
                return "afade=t=in:d=$fadetime"
            };
        } elsif (/^--vfadeout=(.*)$/) {
            my $fadetime = $1;
            push @vfilters, sub {
                my ($in, $out, $from, $to) = @_;
                die "Can't fade out unless exact cut points are provided\n"
                    unless looks_like_number($from) && looks_like_number($to);
                my $duration = $to - $from;
                my $fade_start = round_3dp($duration - $fadetime);
                return "fade=t=out:st=$fade_start:d=$fadetime"
            };
        } elsif (/^--vfadein=(.*)$/) {
            my $fadetime = $1;
            push @vfilters, sub {
                return "fade=t=in:d=$fadetime"
            };
        } elsif (/^--$/) {
            shift;
            last;
        } else {
            die "Bad argument: $_";
        }
    }
    shift;
}

my ($in, $out, $from, $to) = @ARGV;
die "Usage: $0 in.mkv out.mkv cut_from cut_to\n" unless defined $to;

$from = round_3dp normalise_time $from;

my @duration_arg;
if ($to ne 'end') {
    $to = round_3dp normalise_time $to;
    my $duration = round_3dp($to - $from);
    @duration_arg = ('-t', $duration);
}

my @afilters_transformed = map { $_->($in, $out, $from, $to) } @afilters;
my @vfilters_transformed = map { $_->($in, $out, $from, $to) } @vfilters;

if ($hardware eq "amd") {
    push @vfilters_transformed, "format=nv12";
    push @vfilters_transformed, "hwupload";
}

my @filters = ();
push @filters, join(",", @afilters_transformed) if @afilters_transformed;
push @filters, join(",", @vfilters_transformed) if @vfilters_transformed;
if (@filters) {
    @filters_transformed = ('-filter_complex', join(";", @filters));
}

my @command = qw/ffmpeg -hide_banner -y -nostdin/;
my @common_out = qw/-c:a flac -map_chapters -1 -map 0:v -map 0:a/;

if ($hardware eq "nvidia") {
    push @command, qw/-hwaccel cuda -ss/, $from, @duration_arg, '-i', $in, @filters_transformed, qw/-c:v h264_nvenc -preset:v lossless -profile:v high444p/, @common_out, $out;
    unshift @command, qw/sem --ungroup --id nvenc -j 2 --fg/;
} elsif ($hardware eq "amd") {
    push @command, qw/-hwaccel vaapi -ss/, $from, @duration_arg, '-i', $in, @filters_transformed, qw/-c:v h264_vaapi -profile:v high -qp:v 1/, @common_out, $out;
} else {
    push @command, qw/-hwaccel auto -ss/, $from, @duration_arg, '-i', $in, @filters_transformed, qw/-c:v h264 -qp:v 0/, @common_out, $out;
}
print STDERR join(" ", @command), "\n";
exec @command;
die "exec ffmpeg failed: $!\n";
